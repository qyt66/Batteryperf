<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>A18 Pro Stress Test | ZenBench</title>
    <style>
        :root {
            --primary: #ffffff;
            --glass: rgba(0, 0, 0, 0.6);
            --accent: #ff3b30;
            --success: #34c759;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: var(--primary);
            background: #000;
            overflow-x: hidden;
            height: 200vh; /* Allow scrolling */
        }

        /* Parallax Backgrounds */
        .bg-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            background-size: cover;
            background-position: center;
            transition: opacity 1s ease;
            opacity: 0.4;
        }
        
        #bg1 { background-image: url('https://picsum.photos/id/1015/800/1200'); } /* River */
        #bg2 { background-image: url('https://picsum.photos/id/1039/800/1200'); opacity: 0; } /* Waterfall */

        /* 3D Canvas (GPU Test) */
        #canvas-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -2;
            opacity: 0.8;
            pointer-events: none;
        }

        /* HUD Interface */
        .hud {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            background: linear-gradient(to top, black, transparent);
            padding-bottom: 40px;
            z-index: 10;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--glass);
            padding: 10px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .stat-value { font-size: 1.2rem; font-weight: 700; display: block; }
        .stat-label { font-size: 0.7rem; opacity: 0.7; text-transform: uppercase; letter-spacing: 1px; }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 14px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s;
        }

        button:active { transform: scale(0.96); }

        #btn-start { background: var(--primary); color: #000; }
        #btn-stop { background: var(--glass); color: var(--accent); border: 1px solid var(--accent); display: none; }
        
        .header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            text-align: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            z-index: 5;
        }

        h1 { font-size: 1.2rem; font-weight: 500; letter-spacing: -0.5px; }
        p { font-size: 0.8rem; opacity: 0.7; margin-top: 5px; }

        /* Smooth scroll hint */
        .scroll-hint {
            position: fixed;
            top: 50%;
            right: 20px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 0.7rem;
            opacity: 0.5;
            letter-spacing: 2px;
        }

        /* Status indicator */
        .status-dot {
            height: 8px; width: 8px; background: #555; border-radius: 50%; display: inline-block; margin-right: 5px;
        }
        .active .status-dot { background: var(--success); box-shadow: 0 0 10px var(--success); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div class="bg-layer" id="bg1"></div>
    <div class="bg-layer" id="bg2"></div>
    <div id="canvas-container"></div>

    <div class="header">
        <h1>ZenBench A18</h1>
        <p>iPhone 16 Pro Stress Test</p>
    </div>

    <div class="scroll-hint">SCROLL TO RELAX & LOAD</div>

    <div class="hud">
        <div class="stats-grid">
            <div class="stat-card">
                <span class="stat-value" id="cpu-stat">0</span>
                <span class="stat-label">Threads</span>
            </div>
            <div class="stat-card">
                <span class="stat-value" id="gpu-stat">0</span>
                <span class="stat-label">Objects</span>
            </div>
            <div class="stat-card">
                <span class="stat-value" id="mem-stat">0</span>
                <span class="stat-label">MB Used</span>
            </div>
        </div>
        
        <div class="controls">
            <button id="btn-start" onclick="startStressTest()">Ignite Engines</button>
            <button id="btn-stop" onclick="stopStressTest()">Cool Down</button>
        </div>
    </div>

<script>
    // --- AUDIO ENGINE (Web Audio API - No external files) ---
    const AudioEngine = {
        ctx: null,
        oscillators: [],
        gainNode: null,
        isPlaying: false,

        init() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.gainNode = this.ctx.createGain();
            this.gainNode.gain.value = 0.15; // Keep it soothingly low
            this.gainNode.connect(this.ctx.destination);
        },

        playDrone() {
            if (this.isPlaying) return;
            if (!this.ctx) this.init();
            this.ctx.resume();
            
            // Create a "Pink Noise" style drone using multiple oscillators
            const freqs = [55, 110, 165, 220, 275]; // Pentatonic-ish low end
            freqs.forEach(f => {
                const osc = this.ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(f, this.ctx.currentTime);
                
                // Add slight detune for "thick" organic sound
                osc.detune.setValueAtTime(Math.random() * 10 - 5, this.ctx.currentTime);
                
                const oscGain = this.ctx.createGain();
                oscGain.gain.value = 0.1;
                
                osc.connect(oscGain);
                oscGain.connect(this.gainNode);
                osc.start();
                this.oscillators.push({osc, oscGain});
            });
            this.isPlaying = true;
        },

        stop() {
            this.oscillators.forEach(o => {
                o.osc.stop();
                o.osc.disconnect();
            });
            this.oscillators = [];
            this.isPlaying = false;
        }
    };

    // --- STRESS LOGIC ---
    let workers = [];
    let memoryHogs = [];
    let isRunning = false;
    let frameId;

    // GPU Setup (Three.js)
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Create many cubes for GPU stress
    const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const material = new THREE.MeshNormalMaterial({ wireframe: false });
    const cubes = [];
    const MAX_CUBES = 2500; // High count for mobile GPU stress

    camera.position.z = 15;

    function initGPU() {
        // Initial lighter load
        addCubes(500);
        animate();
    }

    function addCubes(count) {
        for(let i=0; i<count; i++) {
            const cube = new THREE.Mesh(geometry, material);
            cube.position.x = (Math.random() - 0.5) * 30;
            cube.position.y = (Math.random() - 0.5) * 30;
            cube.position.z = (Math.random() - 0.5) * 10;
            scene.add(cube);
            cubes.push(cube);
        }
        document.getElementById('gpu-stat').innerText = cubes.length;
    }

    function animate() {
        frameId = requestAnimationFrame(animate);
        
        cubes.forEach((cube, i) => {
            cube.rotation.x += 0.01 + (i * 0.00001);
            cube.rotation.y += 0.01 + (i * 0.00001);
        });

        // Rotate entire scene based on scroll
        const scrollY = window.scrollY;
        scene.rotation.y = scrollY * 0.001;
        
        // Background Opacity Logic
        const bg2 = document.getElementById('bg2');
        if(scrollY > 300) {
            bg2.style.opacity = Math.min((scrollY - 300) / 500, 1);
        } else {
            bg2.style.opacity = 0;
        }

        renderer.render(scene, camera);
    }

    // CPU Stress (Web Workers)
    const workerCode = `
        self.onmessage = function() {
            while(true) {
                // Heavy math
                Math.random() * Math.random();
                const primes = [];
                for(let i=0; i<1000; i++) {
                   // Burn cycles
                }
            }
        };
    `;
    const blob = new Blob([workerCode], {type: 'application/javascript'});
    const workerUrl = URL.createObjectURL(blob);

    function startCPU() {
        const threadCount = navigator.hardwareConcurrency || 4;
        document.getElementById('cpu-stat').innerText = threadCount + " (Max)";
        
        for(let i=0; i<threadCount; i++) {
            const w = new Worker(workerUrl);
            w.postMessage('go');
            workers.push(w);
        }
    }

    // Memory Stress
    function startMem() {
        const interval = setInterval(() => {
            if(!isRunning) { clearInterval(interval); return; }
            try {
                // Allocate 10MB chunks
                const chunk = new Float32Array(2.5 * 1024 * 1024); 
                for(let i=0; i<chunk.length; i++) chunk[i] = Math.random();
                memoryHogs.push(chunk);
                
                const usedApprox = (memoryHogs.length * 10).toFixed(0);
                document.getElementById('mem-stat').innerText = usedApprox;
                
                // Safety Cap for Mobile Browser (approx 1GB to avoid crash loop)
                if(usedApprox > 1000) {
                    clearInterval(interval);
                    document.getElementById('mem-stat').innerText = "1GB (Cap)";
                }
            } catch(e) {
                clearInterval(interval);
            }
        }, 500);
    }

    // Master Controls
    function startStressTest() {
        if(isRunning) return;
        isRunning = true;
        
        // UI Updates
        document.getElementById('btn-start').style.display = 'none';
        document.getElementById('btn-stop').style.display = 'block';
        document.body.classList.add('active');

        // Audio
        AudioEngine.playDrone();

        // 1. CPU
        startCPU();

        // 2. GPU (Add intense load)
        addCubes(2000); 

        // 3. Memory
        startMem();
    }

    function stopStressTest() {
        isRunning = false;

        // UI Updates
        document.getElementById('btn-start').style.display = 'block';
        document.getElementById('btn-stop').style.display = 'none';
        document.body.classList.remove('active');

        // Stop Audio
        AudioEngine.stop();

        // Kill CPU Workers
        workers.forEach(w => w.terminate());
        workers = [];
        document.getElementById('cpu-stat').innerText = "0";

        // Release Memory
        memoryHogs = [];
        document.getElementById('mem-stat').innerText = "0";

        // Reduce GPU load
        // Remove extra cubes, keep base 500
        for(let i=cubes.length-1; i>=500; i--) {
            scene.remove(cubes[i]);
            cubes.pop();
        }
        document.getElementById('gpu-stat').innerText = cubes.length;
    }

    // Init basic visuals
    initGPU();

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
