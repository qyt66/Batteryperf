<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ZenBench Ultimate | A18 Stress Test</title>
    <style>
        :root {
            --font-main: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, sans-serif;
            --glass: rgba(20, 20, 20, 0.7);
            --border: rgba(255, 255, 255, 0.2);
            --accent: #64d2ff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: var(--font-main);
            background: #000;
            color: #fff;
            overflow-x: hidden;
            height: 500vh; /* Scroll space */
        }

        /* --- VISUALS --- */
        
        /* 3D Layer - Now placed BEHIND the background container */
        #canvas-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -10; /* Lowest priority */
            pointer-events: none;
            /* We don't need blending anymore as it's hidden, but we keep opacity */
            opacity: 1.0; 
        }

        /* Background Container - Placed IN FRONT of the canvas */
        .bg-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -5; /* Higher priority than canvas */
            background: #000; /* Ensure base is opaque */
        }

        .bg-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-size: cover;
            background-position: center;
            opacity: 0;
            transition: opacity 0.5s ease-out; /* Smoother transition */
            will-change: opacity;
        }

        /* High-Res Spa/Nature Images */
        .layer-0 { background-image: url('https://images.unsplash.com/photo-1542202229-7d9377a53c03?q=80&w=2000&auto=format&fit=crop'); opacity: 1; } /* Islands */
        .layer-1 { background-image: url('https://images.unsplash.com/photo-1445964047600-cdbdb873673d?q=80&w=2000&auto=format&fit=crop'); } /* Misty Forest */
        .layer-2 { background-image: url('https://images.unsplash.com/photo-1506744038136-46273834b3fb?q=80&w=2000&auto=format&fit=crop'); } /* Waterfall Cliffs */
        .layer-3 { background-image: url('https://images.unsplash.com/photo-1495616811223-4d98c6e9c869?q=80&w=2000&auto=format&fit=crop'); } /* Deep sunset */
        .layer-4 { background-image: url('https://images.unsplash.com/photo-1531366936337-7c912a4589a7?q=80&w=2000&auto=format&fit=crop'); } /* Aurora */


        /* --- UI --- */
        .header {
            position: fixed;
            top: 0; width: 100%;
            padding: 25px;
            text-align: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            z-index: 100;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        
        .header h1 { font-size: 1.4rem; font-weight: 500; letter-spacing: 1px; }
        .header p { font-size: 0.9rem; opacity: 0.8; margin-top: 4px; font-weight: 300; }

        .hud {
            position: fixed;
            bottom: 30px; left: 20px; right: 20px;
            background: var(--glass);
            backdrop-filter: blur(25px) saturate(150%);
            -webkit-backdrop-filter: blur(25px) saturate(150%);
            border: 1px solid var(--border);
            border-radius: 28px;
            padding: 25px;
            z-index: 100;
            box-shadow: 0 20px 40px rgba(0,0,0,0.6);
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 25px;
            padding: 0 10px;
        }

        .stat-box { text-align: center; width: 33%; }
        .stat-num { display: block; font-size: 1.4rem; font-weight: 600; font-variant-numeric: tabular-nums; color: var(--accent); }
        .stat-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; opacity: 0.7; margin-top: 8px; font-weight: 500; }

        button {
            width: 100%;
            padding: 18px;
            border-radius: 20px;
            border: none;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 0.5px;
        }
        
        button:active { transform: scale(0.98); }

        .btn-start { background: #fff; color: #000; box-shadow: 0 5px 15px rgba(255,255,255,0.2); }
        .btn-stop { background: rgba(100, 210, 255, 0.15); color: var(--accent); border: 1px solid var(--accent); display: none; }

        /* Scroll Indicator */
        .scroll-pill {
            position: fixed;
            right: 12px; top: 50%;
            transform: translateY(-50%);
            height: 120px; width: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            z-index: 50;
            overflow: hidden;
        }
        .scroll-progress {
            width: 100%; height: 0%;
            background: #fff;
            box-shadow: 0 0 10px #fff;
            border-radius: 3px;
            transition: height 0.1s ease-out;
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="canvas-overlay"></div>

    <div class="bg-container">
        <div class="bg-layer layer-0"></div>
        <div class="bg-layer layer-1"></div>
        <div class="bg-layer layer-2"></div>
        <div class="bg-layer layer-3"></div>
        <div class="bg-layer layer-4"></div>
    </div>


    <div class="header">
        <h1>ZenBench Ultimate</h1>
        <p>Scroll to Relax â€¢ Stress Test Device</p>
    </div>

    <div class="scroll-pill"><div class="scroll-progress" id="progressBar"></div></div>

    <div class="hud">
        <div class="stats">
            <div class="stat-box">
                <span class="stat-num" id="cpu-val">Top</span>
                <span class="stat-label">CPU Load</span>
            </div>
            <div class="stat-box">
                <span class="stat-num" id="gpu-val">Idle</span>
                <span class="stat-label">GPU State</span>
            </div>
            <div class="stat-box">
                <span class="stat-num" id="mem-val">0</span>
                <span class="stat-label">MB Used</span>
            </div>
        </div>
        <button class="btn-start" onclick="toggleStress(true)">Begin Immersion Test</button>
        <button class="btn-stop" onclick="toggleStress(false)">End Session</button>
    </div>

<script>
    // --- 1. NEW "SPA" AUDIO ENGINE (Procedural Ambient Pad) ---
    const SpaAudio = {
        ctx: null,
        masterGain: null,
        oscillators: [],
        lfo: null,

        init() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0; // Start silent
            this.masterGain.connect(this.ctx.destination);

            // Create a resonant lowpass filter
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = 12; // High resonance for "breathing" sound
            filter.frequency.setValueAtTime(400, this.ctx.currentTime); // Base frequency center

            // Create a very slow LFO (Low Frequency Oscillator) to modulate the filter
            this.lfo = this.ctx.createOscillator();
            this.lfo.type = 'sine';
            this.lfo.frequency.value = 0.08; // Very slow cycle (about 12 seconds)

            // LFO Gain determines how much the filter opens and closes
            const lfoGain = this.ctx.createGain();
            lfoGain.gain.value = 350; // Filter sweeps up and down by 350Hz

            // Connect LFO -> LFO Gain -> Filter Frequency parameter
            this.lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            this.lfo.start();

            // Create two slightly detuned oscillators for a thick "pad" sound
            const freqBase = 146.83; // D3 note (soothing tone)
            
            [freqBase, freqBase * 1.5].forEach((f, index) => {
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth'; // Rich harmonic content
                osc.frequency.value = f;
                // Detune slightly for chorus effect
                osc.detune.value = index === 0 ? -15 : 15; 

                osc.connect(filter);
                osc.start();
                this.oscillators.push(osc);
            });

            filter.connect(this.masterGain);
        },

        fadeIn() {
            if (!this.ctx) this.init();
            this.ctx.resume();
            // Smooth fade in over 4 seconds
            this.masterGain.gain.setTargetAtTime(0.4, this.ctx.currentTime, 1); 
        },

        fadeOut() {
            if(this.masterGain) {
                // Smooth fade out over 3 seconds
                this.masterGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.5);
            }
        }
    };

    // --- 2. SCROLL & PARALLAX LOGIC ---
    const layers = document.querySelectorAll('.bg-layer');
    const progressBar = document.getElementById('progressBar');
    
    window.addEventListener('scroll', () => {
        const scrollTop = window.scrollY;
        // Calculate max scrollable distance
        const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
        const scrollFraction = scrollTop / maxScroll;
        
        progressBar.style.height = `${scrollFraction * 100}%`;

        const totalLayers = layers.length;
        const indexFloat = scrollFraction * (totalLayers - 1);
        const indexCurrent = Math.floor(indexFloat);
        const indexNext = indexCurrent + 1;
        const fade = indexFloat - indexCurrent;

        layers.forEach((layer, i) => {
            if (i === indexCurrent) {
                layer.style.opacity = 1 - fade;
            } else if (i === indexNext) {
                layer.style.opacity = fade;
            } else {
                layer.style.opacity = 0;
            }
        });
        
        // Subtle visual feedback that something is happening behind the scenes
        if(scene) scene.rotation.y = scrollTop * 0.001;
    });

    // --- 3. HIDDEN 3D GPU STRESS (Three.js) ---
    // This runs in the background, hidden by z-index
    const scene = new THREE.Scene();
    // Wider field of view to render more items off-screen
    const camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true }); // Alpha false as it's hidden anyway
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio); 
    document.getElementById('canvas-overlay').appendChild(renderer.domElement);

    // Using a more complex geometry for higher vertex count
    const geometry = new THREE.TorusKnotGeometry(0.5, 0.2, 64, 16);
    const material = new THREE.MeshBasicMaterial({ color: 0x333333, wireframe: true });
    
    // Increase count significantly since they aren't obstructing the view
    const count = 4000; 
    const mesh = new THREE.InstancedMesh(geometry, material, count);
    
    const dummy = new THREE.Object3D();
    for(let i=0; i<count; i++) {
        // Spread them out wider
        dummy.position.set(
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 50 - 20
        );
        dummy.rotation.set(Math.random(), Math.random(), Math.random());
        dummy.updateMatrix();
        mesh.setMatrixAt(i, dummy.matrix);
    }
    scene.add(mesh);
    camera.position.z = 30;

    let gpuStressActive = false;
    function animateGPU() {
        requestAnimationFrame(animateGPU);
        // Only rotate heavily if stress is active
        if(gpuStressActive) {
             mesh.rotation.x += 0.005;
             mesh.rotation.y += 0.007;
        }
        renderer.render(scene, camera);
    }
    animateGPU();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- 4. SYSTEM STRESS LOGIC ---
    let workers = [];
    let memoryArray = [];
    let memInterval;

    // Updated worker blob for slightly harder math
    const workerBlob = new Blob([`
        self.onmessage = function() {
            // Hard burning loop
            while(true) {
                let r = 0;
                // Complex floating point math
                for(let i=1; i<10000; i++) {
                    r += Math.atan(i) * Math.tan(i) / Math.sqrt(i);
                }
            }
        }
    `], { type: "text/javascript" });
    const workerURL = URL.createObjectURL(workerBlob);

    function toggleStress(active) {
        const btnStart = document.querySelector('.btn-start');
        const btnStop = document.querySelector('.btn-stop');
        
        if (active) {
            btnStart.style.display = 'none';
            btnStop.style.display = 'block';
            SpaAudio.fadeIn();
            gpuStressActive = true;
            
            // --- CPU START ---
            // Use navigator.hardwareConcurrency but cap reasonably for mobile web safety
            const threads = Math.min(navigator.hardwareConcurrency || 4, 8); 
            document.getElementById('cpu-val').innerText = threads + " Cores";
            for(let i=0; i<threads; i++) {
                const w = new Worker(workerURL);
                w.postMessage("start");
                workers.push(w);
            }

            // --- GPU RAMP UP ---
            document.getElementById('gpu-val').innerText = "Active";

            // --- MEMORY START ---
            // Allocate larger chunks faster
            memInterval = setInterval(() => {
                try {
                    // 30MB chunks of float32 data
                    const chunk = new Float32Array(7.5 * 1024 * 1024);
                    // Dirty the memory so OS must allocate RAM
                    for(let k=0; k<chunk.length; k+=64) chunk[k] = Math.random();
                    memoryArray.push(chunk);
                    
                    const mb = Math.round(memoryArray.length * 30);
                    document.getElementById('mem-val').innerText = mb;
                    
                    // Safety cap around 2GB to avoid OS killing the browser tab
                    if(mb > 2000) {
                         clearInterval(memInterval);
                         document.getElementById('mem-val').innerText = "2GB (Cap)";
                    }
                } catch(e) {
                    clearInterval(memInterval);
                    document.getElementById('mem-val').innerText = "Err (Cap)";
                }
            }, 400); //Faster allocation speed

        } else {
            btnStart.style.display = 'block';
            btnStop.style.display = 'none';
            SpaAudio.fadeOut();
            gpuStressActive = false;

            // --- CPU STOP ---
            workers.forEach(w => w.terminate());
            workers = [];
            document.getElementById('cpu-val').innerText = "Top";

            // --- GPU RELAX ---
            document.getElementById('gpu-val').innerText = "Idle";

            // --- MEMORY RELEASE ---
            clearInterval(memInterval);
            memoryArray = [];
            document.getElementById('mem-val').innerText = "0";
        }
    }
</script>
</body>
</html>
