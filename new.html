<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>iPhone HTML5 Stress Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #ui {
      position: fixed;
      top: env(safe-area-inset-top, 8px);
      left: env(safe-area-inset-left, 8px);
      right: env(safe-area-inset-right, 8px);
      background: rgba(0, 0, 0, 0.75);
      padding: 10px 12px;
      z-index: 10;
      font-size: 14px;
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    #top-row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    button {
      border: none;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      background: #1e90ff;
      color: #fff;
    }
    button#stopBtn {
      background: #ff4b4b;
    }
    button:active {
      opacity: 0.8;
    }
    label {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    input[type="range"] {
      width: 120px;
    }
    #stats {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 12px;
      opacity: 0.9;
    }
    #gps {
      font-size: 11px;
      opacity: 0.85;
      max-width: 100%;
      word-wrap: break-word;
    }
    canvas {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="top-row">
      <button id="startBtn">Start stress test</button>
      <button id="stopBtn">Stop</button>
      <label>
        CPU load
        <input id="cpuSlider" type="range" min="0" max="100" value="70" />
      </label>
    </div>
    <div id="stats">
      <div>FPS: <span id="fps">0</span></div>
      <div>CPU/frame: <span id="cpuMs">0</span> ms</div>
      <div>GPU points: <span id="gpuPoints">150k</span></div>
      <div>Geolocation: <span id="gpsStatus">idle</span></div>
    </div>
    <div id="gps"></div>
  </div>
  <canvas id="glCanvas"></canvas>

  <script>
    // === Basic DOM references ===
    const canvas = document.getElementById("glCanvas");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const cpuSlider = document.getElementById("cpuSlider");
    const fpsSpan = document.getElementById("fps");
    const cpuMsSpan = document.getElementById("cpuMs");
    const gpuPointsSpan = document.getElementById("gpuPoints");
    const gpsStatusSpan = document.getElementById("gpsStatus");
    const gpsDiv = document.getElementById("gps");

    let running = false;
    let gl, program;
    let positionBuffer, aPositionLoc, uTimeLoc, uResolutionLoc;
    const NUM_POINTS = 150000; // ~AAA-ish GPU load for mobile
    gpuPointsSpan.textContent = (NUM_POINTS / 1000) + "k";

    // FPS tracking
    let lastFrameTime = performance.now();
    let fpsAccum = 0;
    let fpsCount = 0;
    let lastFpsUpdate = performance.now();

    // Geolocation
    let geoWatchId = null;
    let geoUpdateCount = 0;

    // Resize canvas to full screen
    function resizeCanvas() {
      const ratio = window.devicePixelRatio || 1;
      const width = window.innerWidth * ratio;
      const height = window.innerHeight * ratio;
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
        if (gl && uResolutionLoc) {
          gl.viewport(0, 0, width, height);
          gl.uniform2f(uResolutionLoc, width, height);
        }
      }
    }
    window.addEventListener("resize", resizeCanvas);

    // === WebGL setup ===
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Shader compile failed:", gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      if (!vs || !fs) return null;
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error("Program link failed:", gl.getProgramInfoLog(prog));
        gl.deleteProgram(prog);
        return null;
      }
      return prog;
    }

    function initGL() {
      gl = canvas.getContext("webgl", { antialias: false, preserveDrawingBuffer: false });
      if (!gl) {
        alert("WebGL not supported on this device/browser.");
        return;
      }

      const vsSource = `
        attribute vec2 a_position;
        uniform float u_time;
        void main() {
          float angle = u_time * 0.7 + (a_position.x + a_position.y) * 5.0;
          float s = sin(angle);
          float c = cos(angle);
          mat2 rot = mat2(c, -s, s, c);
          vec2 p = rot * a_position;

          float scale = 0.7 + 0.3 * sin(u_time * 2.0 + a_position.x * 10.0);
          p *= scale;

          gl_Position = vec4(p, 0.0, 1.0);
          gl_PointSize = 2.0;
        }
      `;

      const fsSource = `
        precision mediump float;
        uniform float u_time;
        void main() {
          vec2 uv = gl_FragCoord.xy / 1024.0;
          float r = 0.6 + 0.4 * sin(u_time + uv.x * 10.0);
          float g = 0.6 + 0.4 * sin(u_time * 1.3 + uv.y * 12.0);
          float b = 0.6 + 0.4 * sin(u_time * 1.7 + (uv.x + uv.y) * 5.0);
          gl_FragColor = vec4(r, g, b, 1.0);
        }
      `;

      program = createProgram(gl, vsSource, fsSource);
      if (!program) {
        alert("Failed to create WebGL program.");
        return;
      }

      gl.useProgram(program);

      aPositionLoc = gl.getAttribLocation(program, "a_position");
      uTimeLoc = gl.getUniformLocation(program, "u_time");
      uResolutionLoc = gl.getUniformLocation(program, "u_resolution"); // optional

      // Particle positions
      const data = new Float32Array(NUM_POINTS * 2);
      for (let i = 0; i < NUM_POINTS; i++) {
        // Random point inside a circle-ish region for visual density
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.sqrt(Math.random()); // density bias
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        data[i * 2] = x;
        data[i * 2 + 1] = y;
      }

      positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.enableVertexAttribArray(aPositionLoc);
      gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, 0, 0);

      gl.clearColor(0, 0, 0, 1);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      resizeCanvas();
    }

    // === CPU burn ===
    function cpuBurn() {
      // Map slider (0–100) to approx 0–12 ms extra work per frame
      const intensity = parseInt(cpuSlider.value, 10) || 0;
      const targetMs = (intensity / 100) * 12;
      if (targetMs <= 0) return 0;

      const start = performance.now();
      let x = 0;
      while (performance.now() - start < targetMs) {
        // Heavy-ish math to keep CPU busy without infinite loop
        x = Math.sqrt(x * x + Math.random() * 1000.0 + 1.0);
      }
      const elapsed = performance.now() - start;
      return elapsed;
    }

    // === Geolocation ===
    function startGeolocation() {
      if (!("geolocation" in navigator)) {
        gpsStatusSpan.textContent = "not supported";
        return;
      }
      if (geoWatchId !== null) return; // already running

      gpsStatusSpan.textContent = "requesting...";
      geoUpdateCount = 0;
      gpsDiv.textContent = "";

      geoWatchId = navigator.geolocation.watchPosition(
        (pos) => {
          geoUpdateCount++;
          gpsStatusSpan.textContent = "active (" + geoUpdateCount + ")";
          const { latitude, longitude, accuracy, speed } = pos.coords;
          const lines = [
            "Lat: " + latitude.toFixed(6),
            "Lon: " + longitude.toFixed(6),
            "Accuracy: " + accuracy.toFixed(1) + " m",
            "Speed: " + (speed != null ? speed.toFixed(2) + " m/s" : "n/a"),
            "Last fix: " + new Date(pos.timestamp).toLocaleTimeString()
          ];
          gpsDiv.textContent = lines.join(" | ");
        },
        (err) => {
          gpsStatusSpan.textContent = "error: " + err.code;
          console.warn("Geolocation error:", err);
        },
        {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 10000
        }
      );
    }

    function stopGeolocation() {
      if (geoWatchId !== null && navigator.geolocation) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
      }
      gpsStatusSpan.textContent = "stopped";
    }

    // === Main render loop ===
    function renderLoop() {
      if (!running) return;

      const now = performance.now();
      const dt = now - lastFrameTime;
      lastFrameTime = now;

      // FPS stats
      fpsAccum += dt;
      fpsCount++;
      if (now - lastFpsUpdate > 500) { // update display every 0.5s
        const fps = (fpsCount / fpsAccum) * 1000;
        fpsSpan.textContent = fps.toFixed(0);
        fpsCount = 0;
        fpsAccum = 0;
        lastFpsUpdate = now;
      }

      // Draw GPU workload
      if (gl && program) {
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(program);

        const t = now * 0.001; // seconds
        gl.uniform1f(uTimeLoc, t);

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(aPositionLoc);
        gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.POINTS, 0, NUM_POINTS);
      }

      // CPU burn *after* GPU call, to keep both busy
      const cpuMs = cpuBurn();
      cpuMsSpan.textContent = cpuMs.toFixed(1);

      requestAnimationFrame(renderLoop);
    }

    // === Control handlers ===
    function startTest() {
      if (running) return;
      if (!gl) {
        initGL();
      }
      running = true;
      lastFrameTime = performance.now();
      startGeolocation();
      renderLoop();
    }

    function stopTest() {
      running = false;
      stopGeolocation();
      // Canvas remains showing the last frame; that’s fine.
    }

    startBtn.addEventListener("click", startTest);
    stopBtn.addEventListener("click", stopTest);

    // Initial setup
    resizeCanvas();
  </script>
</body>
</html>
