<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>iPhone HTML5 Stress Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #ui {
      position: fixed;
      top: env(safe-area-inset-top, 8px);
      left: env(safe-area-inset-left, 8px);
      right: env(safe-area-inset-right, 8px);
      background: rgba(0, 0, 0, 0.75);
      padding: 10px 12px;
      z-index: 10;
      font-size: 14px;
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    #top-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    button {
      border: none;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      background: #1e90ff;
      color: #fff;
    }
    button#stopBtn {
      background: #ff4b4b;
    }
    label {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    input[type="range"] {
      width: 120px;
    }
    #stats {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 12px;
      opacity: 0.9;
    }
    #gps {
      font-size: 11px;
      opacity: 0.85;
      max-width: 100%;
    }
    canvas {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="top-row">
      <button id="startBtn">Start stress test</button>
      <button id="stopBtn">Stop</button>
      <label>
        CPU load
        <input id="cpuSlider" type="range" min="0" max="100" value="70" />
      </label>
    </div>
    <div id="stats">
      <div>FPS: <span id="fps">0</span></div>
      <div>CPU/frame: <span id="cpuMs">0</span> ms</div>
      <div>GPU points: <span id="gpuPoints">150k</span></div>
      <div>Geolocation: <span id="gpsStatus">idle</span></div>
    </div>
    <div id="gps"></div>
  </div>

  <canvas id="glCanvas"></canvas>

  <script>
    const canvas = document.getElementById("glCanvas");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const cpuSlider = document.getElementById("cpuSlider");
    const fpsSpan = document.getElementById("fps");
    const cpuMsSpan = document.getElementById("cpuMs");
    const gpuPointsSpan = document.getElementById("gpuPoints");
    const gpsStatusSpan = document.getElementById("gpsStatus");
    const gpsDiv = document.getElementById("gps");

    let running = false;
    let gl, program;
    let positionBuffer, aPositionLoc, uTimeLoc;

    const NUM_POINTS = 150000;
    gpuPointsSpan.textContent = "150k";

    let lastFrameTime = performance.now();
    let fpsAccum = 0;
    let fpsCount = 0;
    let lastFpsUpdate = performance.now();

    let geoWatchId = null;

    function resizeCanvas() {
      const ratio = window.devicePixelRatio || 1;
      const width = window.innerWidth * ratio;
      const height = window.innerHeight * ratio;
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
        if (gl) gl.viewport(0, 0, width, height);
      }
    }
    window.addEventListener("resize", resizeCanvas);

    function createShader(gl, type, src) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    function createProgram(gl, vs, fs) {
      const v = createShader(gl, gl.VERTEX_SHADER, vs);
      const f = createShader(gl, gl.FRAGMENT_SHADER, fs);
      if (!v || !f) return null;
      const prog = gl.createProgram();
      gl.attachShader(prog, v);
      gl.attachShader(prog, f);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
        return null;
      }
      return prog;
    }

    function initGL() {
      gl = canvas.getContext("webgl", { antialias: false });
      if (!gl) {
        alert("WebGL unsupported.");
        return;
      }

      const vsSource = `
        attribute vec2 a_position;
        uniform float u_time;
        void main() {
          float angle = u_time * 0.7 + (a_position.x + a_position.y) * 5.0;
          float s = sin(angle);
          float c = cos(angle);
          mat2 rot = mat2(c, -s, s, c);
          vec2 p = rot * a_position;

          float scale = 0.7 + 0.3 * sin(u_time * 2.0 + a_position.x * 10.0);
          p *= scale;

          gl_Position = vec4(p, 0.0, 1.0);
          gl_PointSize = 2.0;
        }
      `;

      const fsSource = `
        precision mediump float;
        uniform float u_time;
        void main() {
          vec2 uv = gl_FragCoord.xy * 0.001;
          float r = 0.6 + 0.4 * sin(u_time + uv.x * 10.0);
          float g = 0.6 + 0.4 * sin(u_time * 1.3 + uv.y * 12.0);
          float b = 0.6 + 0.4 * sin(u_time * 1.7 + (uv.x + uv.y) * 5.0);
          gl_FragColor = vec4(r, g, b, 1.0);
        }
      `;

      program = createProgram(gl, vsSource, fsSource);
      if (!program) {
        alert("Failed to create WebGL program.");
        return;
      }

      gl.useProgram(program);

      aPositionLoc = gl.getAttribLocation(program, "a_position");
      uTimeLoc = gl.getUniformLocation(program, "u_time");

      const data = new Float32Array(NUM_POINTS * 2);
      for (let i = 0; i < NUM_POINTS; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.sqrt(Math.random());
        data[i * 2] = radius * Math.cos(angle);
        data[i * 2 + 1] = radius * Math.sin(angle);
      }

      positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.enableVertexAttribArray(aPositionLoc);
      gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, 0, 0);

      gl.clearColor(0, 0, 0, 1);

      resizeCanvas();
    }

    function cpuBurn() {
      const intensity = parseInt(cpuSlider.value, 10);
      const targetMs = (intensity / 100) * 12;
      const start = performance.now();
      let x = 0;
      while (performance.now() - start < targetMs) {
        x = Math.sqrt(x * x + Math.random() * 1000 + 1);
      }
      return performance.now() - start;
    }

    function startGeolocation() {
      if (!navigator.geolocation) return;
      if (geoWatchId !== null) return;

      gpsStatusSpan.textContent = "requesting...";

      geoWatchId = navigator.geolocation.watchPosition(
        (pos) => {
          gpsStatusSpan.textContent = "active";
          const { latitude, longitude, accuracy } = pos.coords;
          gpsDiv.textContent =
            `Lat: ${latitude.toFixed(5)} | Lon: ${longitude.toFixed(5)} | Acc: ${accuracy}m`;
        },
        (err) => {
          gpsStatusSpan.textContent = "error";
        },
        { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
      );
    }

    function stopGeolocation() {
      if (geoWatchId !== null) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
      }
      gpsStatusSpan.textContent = "stopped";
    }

    function renderLoop() {
      if (!running) return;

      const now = performance.now();
      const dt = now - lastFrameTime;
      lastFrameTime = now;

      fpsAccum += dt;
      fpsCount++;

      if (now - lastFpsUpdate > 500) {
        const fps = (fpsCount / fpsAccum) * 1000;
        fpsSpan.textContent = fps.toFixed(0);
        fpsCount = 0;
        fpsAccum = 0;
        lastFpsUpdate = now;
      }

      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);
      gl.uniform1f(uTimeLoc, now * 0.001);

      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, 0, 0);

      gl.drawArrays(gl.POINTS, 0, NUM_POINTS);

      const cpuMs = cpuBurn();
      cpuMsSpan.textContent = cpuMs.toFixed(1);

      requestAnimationFrame(renderLoop);
    }

    function startTest() {
      if (running) return;
      if (!gl) initGL();
      running = true;
      lastFrameTime = performance.now();
      startGeolocation();
      renderLoop();
    }

    function stopTest() {
      running = false;
      stopGeolocation();
    }

    startBtn.addEventListener("click", startTest);
    stopBtn.addEventListener("click", stopTest);

    resizeCanvas();
  </script>
</body>
</html>
