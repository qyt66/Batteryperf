<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>A18 Pro Benchmark</title>
    <style>
        /* AAA Game UI Styling */
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
            background: radial-gradient(circle, transparent 60%, rgba(0,0,0,0.8) 100%);
        }

        .panel {
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 16px;
            width: fit-content;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        h1 { margin: 0 0 5px 0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; color: #aaa; }
        .stat { font-family: "SF Mono", monospace; font-size: 13px; color: #0f0; margin-bottom: 4px; }
        .stat span { color: #fff; }
        .warn { color: #ffcc00; font-size: 10px; margin-top: 5px; display: block;}

        #controls { align-self: center; text-align: center; margin-bottom: 30px; }
        
        button {
            background: #007AFF; color: white; border: none;
            padding: 18px 40px; font-size: 18px; border-radius: 30px;
            font-weight: 600; cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 122, 255, 0.4);
            transition: transform 0.1s, background 0.2s;
        }
        button:active { transform: scale(0.95); background: #005ecb; }
        button.stop { background: #FF3B30; box-shadow: 0 0 15px rgba(255, 59, 48, 0.4); }

    </style>
</head>
<body>

    <canvas id="glCanvas"></canvas>

    <div id="hud">
        <div class="panel">
            <h1>Metrics (ProMotion)</h1>
            <div class="stat">FPS: <span id="fpsVal">0</span></div>
            <div class="stat">Res: <span id="resVal">--</span> px</div>
            <div class="stat">Cores: <span id="coreVal">0</span> (A18 Optimized)</div>
            <div class="stat">Memory: <span id="memVal">Normal</span></div>
            <div class="stat">GPS: <span id="gpsVal">Standby</span></div>
            <span class="warn">⚠️ Battery drain will be significant.</span>
        </div>

        <div id="controls">
            <button id="actionBtn" onclick="toggleTest()">INITIATE STRESS TEST</button>
        </div>
    </div>

<script>
    // CONFIGURATION
    const IS_RETINA = true; // Forces Native Resolution (2868x1320 on 16 Pro Max)
    
    let isRunning = false;
    let workers = [];
    let animationId;
    let gpsWatchId;
    let frameCount = 0;
    let lastTime = performance.now();

    // ELEMENTS
    const ui = {
        fps: document.getElementById('fpsVal'),
        res: document.getElementById('resVal'),
        cores: document.getElementById('coreVal'),
        mem: document.getElementById('memVal'),
        gps: document.getElementById('gpsVal'),
        btn: document.getElementById('actionBtn')
    };

    // --- 1. A18 GPU OPTIMIZED SHADER (IFS FRACTAL) ---
    const canvas = document.getElementById("glCanvas");
    const gl = canvas.getContext("webgl", {
        powerPreference: "high-performance", // Hint to iOS to use max power
        antialias: false
    });

    function resize() {
        // On 16 Pro Max, devicePixelRatio is 3. This creates HUGE internal resolution.
        const dpr = IS_RETINA ? window.devicePixelRatio : 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
        ui.res.innerText = `${canvas.width} x ${canvas.height}`;
    }
    window.addEventListener('resize', resize);
    resize();

    const vsSource = `attribute vec4 p; void main(){gl_Position=p;}`;
    
    // This shader uses Raymarching on an Iterated Function System
    // It is computationally expensive per pixel, designed to saturate the 6 GPU cores.
    const fsSource = `
        precision highp float;
        uniform float t;
        uniform vec2 r;

        // Rotate function
        mat2 rot(float a) { float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }

        // SDF for a Box
        float sdBox(vec3 p, vec3 b) {
            vec3 q = abs(p) - b;
            return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
        }

        // Scene Map: Iterated Function System (Fractal)
        float map(vec3 p) {
            p.z -= 1.0; // Move scene
            p.xy *= rot(t * 0.1);
            
            float scale = 1.0;
            float d = 1000.0;
            
            // Fold space 6 times (Heavy math per pixel)
            for(int i=0; i<6; i++) {
                p = abs(p) - vec3(0.4, 0.2, 0.3); // Fold
                p.xy *= rot(0.5 + t*0.05);        // Rotate
                p.xz *= rot(0.3);
                
                p *= 1.8; // Scale up
                scale *= 1.8;
                
                // Add geometry
                d = min(d, sdBox(p, vec3(0.4, 2.0, 0.1)) / scale);
            }
            return d;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - r) / r.y;
            
            // Camera setup
            vec3 ro = vec3(0.0, 0.0, -3.5);
            vec3 rd = normalize(vec3(uv, 1.2));
            
            // Raymarching loop (increased iterations for A18)
            float d_total = 0.0;
            int i_count = 0;
            for(int i=0; i<80; i++) {
                vec3 p = ro + rd * d_total;
                float d = map(p);
                d_total += d;
                i_count = i;
                if(d < 0.001 || d_total > 20.0) break;
            }
            
            // Lighting simulation
            vec3 col = vec3(0.0);
            if(d_total < 20.0) {
                vec3 p = ro + rd * d_total;
                // Cheap normals via derivatives
                vec3 normal = normalize(cross(dFdx(p), dFdy(p))); 
                vec3 light = normalize(vec3(sin(t), 1.0, cos(t)));
                
                float diff = max(dot(normal, light), 0.0);
                float amb = 0.1;
                
                // Glow based on iterations (Heatmap look)
                float glow = float(i_count) / 80.0;
                
                col = vec3(diff + amb);
                col += vec3(1.0, 0.4, 0.1) * glow * 2.0; // Add orange "heat"
            }
            
            gl_FragColor = vec4(col, 1.0);
        }
    `;

    // Compile Helpers
    function createShader(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
        return s;
    }
    const pgm = gl.createProgram();
    gl.attachShader(pgm, createShader(gl.VERTEX_SHADER, vsSource));
    gl.attachShader(pgm, createShader(gl.FRAGMENT_SHADER, fsSource));
    gl.linkProgram(pgm);
    gl.useProgram(pgm);
    
    // Buffer Setup
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    
    const locT = gl.getUniformLocation(pgm, "t");
    const locR = gl.getUniformLocation(pgm, "r");

    // --- 2. A18 MEMORY & CPU STRESS (WEB WORKERS) ---
    // We use a blob to spawn workers that act as independent threads.
    // We add ArrayBuffer operations to stress the Unified Memory bandwidth.
    const workerScript = `
        self.onmessage = function() {
            // 16MB buffer per worker
            const size = 4 * 1024 * 1024; 
            const arr = new Float32Array(size); 
            
            let k = 0.0;
            while(true) {
                // 1. Math Stress (ALU)
                k += Math.sin(k) * Math.tan(k) + Math.sqrt(k+1.0);
                
                // 2. Memory Bandwidth Stress
                // Random writes force the memory controller to work
                for(let i=0; i<1000; i++) {
                    let idx = Math.floor(Math.random() * size);
                    arr[idx] = k;
                }
            }
        };
    `;
    const blob = new Blob([workerScript], {type: 'application/javascript'});
    const url = URL.createObjectURL(blob);

    function toggleTest() {
        if(isRunning) stop();
        else start();
    }

    function start() {
        isRunning = true;
        ui.btn.innerText = "ABORT TEST";
        ui.btn.className = "stop";

        // A. Start 120Hz Render Loop
        loop();

        // B. Start CPU/Memory Burners
        // iPhone 16 Pro Max has 6 cores, but iOS usually exposes more logical threads or clamps concurrency.
        const threads = navigator.hardwareConcurrency || 6;
        ui.cores.innerText = `${threads} Active`;
        ui.mem.innerText = "Allocating Buffers...";
        
        for(let i=0; i<threads; i++) {
            const w = new Worker(url);
            w.postMessage("go");
            workers.push(w);
        }
        ui.mem.innerText = "Bandwidth Saturation";

        // C. Start GPS High Accuracy
        if(navigator.geolocation) {
            ui.gps.innerText = "Acquiring Satellites...";
            gpsWatchId = navigator.geolocation.watchPosition(
                (pos) => { 
                    // Just receiving data keeps radio active
                    ui.gps.innerText = `Active (${pos.coords.accuracy.toFixed(0)}m acc)`; 
                }, 
                (e) => ui.gps.innerText = "GPS Restricted",
                { enableHighAccuracy: true, maximumAge: 0 }
            );
        }
    }

    function stop() {
        isRunning = false;
        ui.btn.innerText = "INITIATE STRESS TEST";
        ui.btn.className = "";
        cancelAnimationFrame(animationId);
        
        workers.forEach(w => w.terminate());
        workers = [];
        
        if(gpsWatchId) navigator.geolocation.clearWatch(gpsWatchId);
        
        ui.cores.innerText = "0";
        ui.mem.innerText = "Normal";
        ui.gps.innerText = "Standby";
        ui.res.innerText = "--";
        ui.fps.innerText = "0";
    }

    function loop(now) {
        if(!isRunning) return;

        // Draw Shader
        gl.uniform1f(locT, performance.now() * 0.001);
        gl.uniform2f(locR, canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // Calc FPS
        frameCount++;
        const t = performance.now();
        if(t - lastTime >= 1000) {
            ui.fps.innerText = frameCount;
            // Dynamic color for FPS
            ui.fps.style.color = frameCount > 100 ? "#00ff00" : (frameCount > 50 ? "#fff" : "#ff0000");
            frameCount = 0;
            lastTime = t;
        }

        animationId = requestAnimationFrame(loop);
    }

</script>
</body>
</html>